---
name: Build DistinctionOS
on:
  pull_request:
    branches:
      - main
  schedule:
    - cron: "05 8 */4 * *" # 2:05am Mountain time every 4 days
  push:
    branches:
      - main
    paths-ignore:
      - ".github/**"
      - "**/README.md"
      - "**/claude.md"
      - "repo_files/**"
  workflow_dispatch:

env:
  IMAGE_DESC: "Bazzite but with custom modifications"
  IMAGE_NAME: "${{ github.event.repository.name }}"
  IMAGE_REGISTRY: "ghcr.io/${{ github.repository_owner }}"
  DEFAULT_TAG: "testing"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: true

jobs:
  build_push:
    name: Build and push image
    runs-on: ubuntu-24.04

    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # For changelog generation

      - name: Maximize build space
        uses: jlumbroso/free-disk-space@v1.3.1
        with:
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: false # Keep docker images for caching
          swap-storage: true

      - name: Prepare environment
        run: |
          echo "IMAGE_REGISTRY=${IMAGE_REGISTRY,,}" >> ${GITHUB_ENV}
          echo "IMAGE_NAME=${IMAGE_NAME,,}" >> ${GITHUB_ENV}
          echo "TIMESTAMP=$(date +%Y%m%d)" >> ${GITHUB_ENV}

      - name: Generate tags
        id: generate-tags
        shell: bash
        run: |
          TIMESTAMP="${{ env.TIMESTAMP }}"
          BUILD_TAGS=()

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              BUILD_TAGS+=("pr-${{ github.event.number }}")
              BUILD_TAGS+=("${GITHUB_SHA::7}")
          else
              BUILD_TAGS+=("${DEFAULT_TAG}")
              BUILD_TAGS+=("${DEFAULT_TAG}-${TIMESTAMP}")
              BUILD_TAGS+=("latest")
          fi

          echo "tags=${BUILD_TAGS[*]}" >> $GITHUB_OUTPUT

      - name: Get previous image reference
        id: prev-ref
        run: |
          # Try to get yesterday's build for better rechunk optimization
          YESTERDAY=$(date -d "yesterday" +%Y%m%d)
          PREV_TAG="${DEFAULT_TAG}-${YESTERDAY}"

          # Check if yesterday's image exists
          if skopeo inspect docker://${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${PREV_TAG} &>/dev/null; then
            echo "prev_ref=${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${PREV_TAG}" >> $GITHUB_OUTPUT
            echo "Found previous build: ${PREV_TAG}"
          else
            # Fall back to stable tag
            echo "prev_ref=${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${DEFAULT_TAG}" >> $GITHUB_OUTPUT
            echo "Using stable tag as previous reference"
          fi

      - name: Image Metadata
        uses: docker/metadata-action@v5
        id: metadata
        with:
          images: |
            ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}
          labels: |
            org.opencontainers.image.title=${{ env.IMAGE_NAME }}
            org.opencontainers.image.description=${{ env.IMAGE_DESC }}
            org.opencontainers.image.version=${{ env.DEFAULT_TAG }}-${{ env.TIMESTAMP }}
            io.artifacthub.package.readme-url=https://raw.githubusercontent.com/${{ github.repository }}/main/README.md
            containers.bootc=1

      - name: Build image (rootful)
        id: build_image
        run: |
          # Build with caching for faster rebuilds
          sudo buildah bud \
            --format docker \
            --layers \
            --cache-from ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${DEFAULT_TAG} \
            --tag "localhost/${{ env.IMAGE_NAME }}:build" \
            --file Containerfile \
            .

      - name: Clean up pre-rechunk
        run: |
          # Remove all non-localhost images to save space
          images=$(sudo podman images -n --format '{{.ID}} {{.Repository}}' | grep -v localhost | awk '{print $1}')
          if [ -n "${images}" ]; then
            echo "${images}" | xargs -r sudo podman rmi --force || true
          fi

      - name: Run Rechunker
        id: rechunk
        uses: hhd-dev/rechunk@v1.2.3
        with:
          rechunk: "ghcr.io/hhd-dev/rechunk:v1.2.3"
          ref: "localhost/${{ env.IMAGE_NAME }}:build"
          prev-ref: "${{ steps.prev-ref.outputs.prev_ref }}"
          skip_compression: false
          max-layers: 100
          labels: ${{ steps.metadata.outputs.labels }}

      - name: Generate changelog
        id: changelog
        if: github.event_name != 'pull_request'
        run: |
          cat > .github/scripts/generate-changelog.sh << 'EOF'
          #!/bin/bash
          # Generate changelog based on commits since last stable build

          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            LAST_TAG=$(git rev-list --max-parents=0 HEAD)
          fi

          echo "## Changes in this build" > /tmp/changelog.md
          echo "" >> /tmp/changelog.md

          # Get commits since last tag
          git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" >> /tmp/changelog.md

          echo "" >> /tmp/changelog.md
          echo "### Rechunker Statistics" >> /tmp/changelog.md
          if [ -f "${{ steps.rechunk.outputs.changelog }}" ]; then
            echo '```' >> /tmp/changelog.md
            cat "${{ steps.rechunk.outputs.changelog }}" >> /tmp/changelog.md
            echo '```' >> /tmp/changelog.md
          fi

          # Output to GitHub summary
          cat /tmp/changelog.md >> $GITHUB_STEP_SUMMARY

          # Save for potential release notes
          echo "changelog_file=/tmp/changelog.md" >> $GITHUB_OUTPUT
          EOF

          chmod +x .github/scripts/generate-changelog.sh
          .github/scripts/generate-changelog.sh

      - name: Login to GitHub Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push rechunked image to GHCR
        if: github.event_name != 'pull_request'
        run: |
          # Optimized push directly from rechunker OCI directory
          for tag in ${{ steps.generate-tags.outputs.tags }}; do
            echo "Pushing ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${tag}"

            sudo skopeo copy \
              --dest-creds "${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}" \
              --dest-compress \
              --dest-compress-format gzip \
              --retry-times 3 \
              oci:${{ steps.rechunk.outputs.location }} \
              docker://${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${tag}
          done

          # Clean up rechunker output
          sudo rm -rf ${{ steps.rechunk.outputs.location }}

      - name: Install Cosign
        if: github.event_name != 'pull_request'
        uses: sigstore/cosign-installer@v3

      - name: Sign container image with Cosign
        if: github.event_name != 'pull_request'
        env:
          COSIGN_EXPERIMENTAL: false
        run: |
          # Cosign login using GitHub OIDC (keyless signing)
          for tag in ${{ steps.generate-tags.outputs.tags }}; do
            echo "Signing ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${tag}"

            # Use keyless signing with GitHub OIDC
            cosign sign --yes \
              ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${tag}
          done

      # Alternative: If you have a private key
      - name: Sign with private key (if available)
        if: github.event_name != 'pull_request' && env.HAS_SIGNING_KEY == 'true'
        env:
          COSIGN_EXPERIMENTAL: false
          COSIGN_PRIVATE_KEY: ${{ secrets.SIGNING_SECRET }}
          HAS_SIGNING_KEY: ${{ secrets.SIGNING_SECRET != '' }}
        run: |
          if [ -n "$COSIGN_PRIVATE_KEY" ]; then
            for tag in ${{ steps.generate-tags.outputs.tags }}; do
              echo "Signing with private key: ${tag}"
              cosign sign --yes --key env://COSIGN_PRIVATE_KEY \
                ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${tag}
            done
          fi

      - name: Generate SBOM
        if: github.event_name != 'pull_request'
        run: |
          # Generate Software Bill of Materials
          for tag in ${{ steps.generate-tags.outputs.tags }}; do
            syft ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${tag} \
              -o spdx-json=/tmp/sbom-${tag}.json

            # Attach SBOM to image
            cosign attach sbom \
              --sbom /tmp/sbom-${tag}.json \
              ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${tag}
          done
